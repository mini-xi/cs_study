# 운영체제

## 1. 운영체제의 개념

![1](https://user-images.githubusercontent.com/97429679/167586755-d1c4f082-fce8-4e74-a0e5-85094f8a4fde.png)

[https://okjh.tistory.com/8](https://okjh.tistory.com/8)

- CPU를 동작시키기 위한 프로그램이다
- 소프트웨어와 하드웨어간의 중간다리 역할을 한다.
- 프로세서, 메모리, 입출력장치, 통신장치 등 컴퓨터 자원을 효과적으로 활용할수 있게 관리한다.

### 1. 운영체제의 목적

- 편리성
- 효율성(처리량 향상, 지연 응답시간 단축, 신뢰도 향상, 사용 가능도 향상)

### 2. 운영체제의 역할에 따른 기능

1. **자원관리**
    1. 메모리 관리 
        - 메모리의 어느 부분을 사용하고 누가 사용하는지 점검
        - 메모리에 저장할 프로세스 결정
        - 메모리를 할당하고 회수하는 방법 결정
    2. 보조기억장치 관리
        - 빈 여유 공간 관리
        - 새로운 파일 작성 시 저장 장소 할당
        - 메모리 접근 요청 스케줄링
        - 파일을 생성하고 삭제
    3. 프로세스 관리
        
        (프로세스 : 실행되고 있는 컴퓨터 프로그램)
        
        - 프로세스와 스레드 스케줄링
        - 사용자 프로세스와 시스템 프로세스 생성 제거
        - 프로세스 중지, 재 수행
        - 프로세스 동기화 방법 제공
        - 프로세스 통신 방법 제공
        - 교착상태(deadlock)를 방지하는 방법 제공
    4. 주변 장치 (입출력) 관리
        - 임시저장(버퍼-캐싱) 시스템 기능 제공
        - 일반 장치용 드라이버 인터페이스 제공
        - 특정 장치 드라이버 제공
    5. 파일 관리
        - 파일 생성 , 삭제
        - 디렉터리 생성, 삭제
        - 보조기억장치의 파일 맵핑
        - 안전한(비휘발성) 저장 장치 파일 저장

1. **시스템 관리**
    1. 시스템 보호
        - 접근 권한 제어(어느 사용자가 어디까지 접근 가능한지 제어)로 데이터와 시스템 보안
    2. 네트워킹
        - 경로 설정, 접속 정책, 충돌, 보안 등을 고려
    3. 명령 해석기
        - 사용자가 입력한 명령을 제어문으로 운영체제에 전달

## 2. 운영체제의 발전

### 1. 운영체제의 발전 과정

1. 1940년대 
    - **운영체제가 존재하지 않았다**.
    - 하나의 프로그램을 위한 컴퓨터로 단순 작업을 처리
    - 사용자가 기계어로 직접 프로그램 작성하고 실행하는 작업별 순차 처리 시스템을 사용

1. 1950년대
    - 컴퓨터 사용시 최대한 효율적으로 작업들을 하는것에 관심
    - 비슷한 데이터 발생시마다 즉시 처리하지 않고 데이터를 일정 기간 또는 일정량이 될 때까지 모아 두었다가 한꺼번에 처리하는 **일괄 처리 시스템** 사용
    - 단점 : 입출력장치가 프로세서보다 속도가 느려서 CPU가 쉬는 상태가 발생
        
        ⇒ 보완 : 모니터링, 버퍼링, 스풀링
        
        - 버퍼링 : CPU가 어떤 작업을 처리하고 다음 입출력을 기다리는 것이 아니라 작업을 처리하는 동안 다음으로 처리할 작업을 미리 읽어 저장해 두는 것이다.
            
            ![2](https://user-images.githubusercontent.com/97429679/167586783-5ef57c54-3a41-46a5-b5aa-560bfbd64d80.png)

            
            [https://dololak.tistory.com/84](https://dololak.tistory.com/84)
            
        - 스풀링 : 버퍼링과 같이 입출력 장치의 처리할 내용을 미리 읽는 것이며, 버퍼링과 다르게 여러 작업의 입출력과 계산을 중복 처리할 수 있다.
        
2. 1960년대
    - 여러 프로그램을 동시에 실행할수 있는 **다중 프로그래밍** 사용
    - **시분할, 다중처리, 실시간 시스템**으로 처리 능력 향상
    - 하이브리드 언어 개발 (C언어)
    
3. 1970년대 중반 ~ 1990년대
    - 네트워크 중심 시스템
    - **분산처리 시스템**을 확립하여 데이터 발생하는 곳으로 컴퓨터의 능력을 가져오는데 관심

1. 2000년대 이후 
    - 모바일 기기의 대중화로 모바일 운영체제인 심비안, 안드로이드, iOS 등이 등장
    - 각종 사물에 컴퓨터 칩과 통신 기능이 내장되어 인터넷에 연결하는 기술이 등장
    - 물리적 자원을 추상화하여 논리적 자원 형태로 처리하는 **가상화** 기술이 본격적으로 확산
    - 서버 가상화 기술을 이용하여 사용자에게 인프라나 자원(IaaS), 개발환경(PaaS), 소프트웨어(SaaS) 등을 서비스 형태로 제공하는 **클라우드 컴퓨팅**이 발전
    

### 2. 운영체제의 유형

1. 일괄 처리 시스템

1. 다중 프로그래밍 시스템
    - 하나의 프로세스에서 프로그램을 여러개 실행시키는 것
    - CPU가 효율적으로 작동
    
    ![3](https://user-images.githubusercontent.com/97429679/167586795-b85d5fee-5641-4fe0-9efe-933fdb4941a5.png)
    

1. 시분할 시스템
    - 다중 프로그래밍 시스템에서 프로세서 스케줄링이라는 개념을 더한 것
    - 다중 프로그래밍 시스템의 목표가 프로세서 사용의 최대화라면 시분할 시스템의 목표는 응답시간 최소화에 있다.
    - 단점 : 신뢰성 문제, 데이터 통신의 문제
    
2. 다중 처리 시스템
    - 하나의 시스템에서 프로세서를 여러개 사용하여 처리 능력을 높인 것
    - 프로세서 하나가 고장나도 다른 프로세서를 사용하여 작업을 계속할수 있으므로 신뢰성이 높다.
    - 프로세서 간의 연결, 상호작용, 역할 분담 등을 고려해야한다.
    
    ![4](https://user-images.githubusercontent.com/97429679/167586804-e7a46047-3da8-4848-b426-abdc95dce2e0.png)
    

1. 실시간 처리 시스템
    - 특정 이벤트 발생시 즉시 응답하는 시스템
    - 즉시 응답 해야 하므로 실시간 처리 시스템은 항상 온라인 상태여야 한다.
    - 실시간 처리 시스템의 두가지 유형
        - 경성 실시간 처리 시스템 : 시간의 제약 조건을 지키지 못하면 시스템에 치명적인 영향을 주는 시스템 (발전소 제어, 철도 자동 제어, 미사일 자동 조준 등)
        - 연성 실시간 처리 시스템 : 작업 실행에서 시간 제약 조건은 있으나 이를 지키지 못해도 전체 시스템에 치명적인 영향을 미치지 않는 시스템 (동영상 재생)

1. 분산 처리 시스템
    - 통신을 통해 여러 위치에서 데이터를 처리, 저장하고 여러 사용자가 공유 가능한 시스템
    

[강의 -  [http://www.kocw.net/home/cview.do?cid=5b1beab524a7f258](http://www.kocw.net/home/cview.do?cid=5b1beab524a7f258)]
