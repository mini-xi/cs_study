# 프로세스와 스레드

## 1. 프로세스

### 1. 프로세스란?

- 실행(executing, running) 중인 프로그램
- 곧 실행이 가능한(ready 상태) PCB(process control balck)를 지닌 프로그램
- PCB : 프로세스에 관한 모든 정보(프로세스의 상태, 고유번호, 우선순위, 포인터, 저장공간 등)를 가지고 있으며, 모든 프로세스는 각기 고유의 PCB를 지니고 있다. PCB들은 서로 링크되어 있는 경우가 대부분이며, 준비완료 리스트나 대기리스트는 FIFO 큐, 우선순위 큐, 트리구조, 스택 또는 단순한 무순서의 연결리스트들로서 PCB들을 연결한다.
- 프로그램 카운터(program counter)를 지닌 프로그램
- 능동적 개체(entity)로, 순차적으로 수행하는 프로그램

### 2. 프로세스의 구성 요소

![Untitled 1](https://user-images.githubusercontent.com/97429679/168655550-ab04b31a-0862-46fc-a6de-82e781f3f537.png)

<[https://zeichi.tistory.com/27](https://zeichi.tistory.com/27)>

1. Code 영역 : 프로그램의 코드 자체가 바이너리 코드로 저장되는 공간
2. Data 영역 : 프로그램의 전역변수나 정적변수의 할당을 위한 공간
3. Heap 영역 : 동적 할당을 위한 저장 공간
4. Stack 영역 : 지역변수 할당과 함수 호출 시 전달되는 인수(argument)값의 저장 공간

### 3. 프로세스의 상태

![Untitled 2](https://user-images.githubusercontent.com/97429679/168655572-08385118-dd24-4924-911b-aec652d150ad.png)

<[https://sangchul.kr/99](https://sangchul.kr/99)>

- 프로세스 상태
    - 실행(Run) : 프로세스가 중앙처리장치를 차지하고 있는 상태
    - 준비(Ready) : 중앙처리장치가 사용 가능하게 될 때 그것을 할당 받을 수 있는 상태
    - 대기(Wait, Block) : 프로세스가 중앙처리장치를 차지하고 처리하다가 입출력 처리 등을 하게 되면 중앙처리장치를 양도하고 입출력 처리가 완료될 때까지 대기하고 있는 상태
    
- 프로세스 상태 전이
    1. 작업이 시스템에 제출(Submit)되면 **스풀러(SPOOLer)**에 의해 디스크에 수록되어 접수 상태로 전이
    2. 이 프로그램이 **Job 스케줄러**를 통해 시행될 프로세스를 만들어 준비 리스트의 가장 뒤에 삽입
    3. **프로세스 스케줄러**는 준비 상태에 있는 여러 프로세스 중 실행될 프로세스를 선정하여 CPU를 할당하며, 프로세스는 준비 상태에서 실행 상태로 전이
    4. 할당 시간이 지나도록 CPU를 차지해야 하는 경우, 일단 준비 상태로 전이
        - 할당 시간 : 한 프로세스가 시스템을 독점하는 것을 방지하기 위하여 지정한 CPU 점유 시간
    5. 할당 시간을 초과하기 전에 입출력이 발생하면 CPU를 양도하고 입출력이 완료될 때까지 대기 상태로 전이
    6. 입출력 처리가 완료되면 대기 상태의 프로세스에게 입출력 완료를 알려 준비 상태로 전이 
    
- 트래픽 제어기(traffic controller)
    - 여러가지 프로세스의 상태에 대한 조사와 통보를 담당하는 제어기
    - dispatch : 준비 상태 → 실행 상태
    - timer runout : 실행 상태 → 준비 상태
    - block : 실행 상태 → 대기 상태
    - wake up : 대기 상태 → 준비 상태
    

### 4. 프로세스 스케줄링

1. 스케줄링의 목적
    - 공정성 : 어떤 프로세스도 무한대기 상태가 되어서는 안되고 , 모든 프로세스들이 공평하게 취급되어야 한다.
    - 처리 능력의 최대화
    - 응답 시간의 최소화
    - 예측 가능 : 주어진 작업은 시스템 내부의 부하에 상관없이 거의 같은 비용, 같은 시간 내에 수행되어야 한다.
    - 오버헤드 최소화
    - 자원 사용의 균형 유지 : 스케줄링 메커니즘들은 해당 시스템의 자원들을 쉬게 해서는 안되며, 프로세스들이 사용되지 않는 자원들을 사용하도록 해야 한다.
    - 응답과 이용 간의 균형 유지
    
2. 방법, 환경별 분류
    - 선점 / 비선점(preemptive/ non-preemptive) 스케줄링
        - 비선점 : 하나의 프로세스에 중앙처리장치가 할당되면 그 프로세스의 수행이 끝날 때까지 중앙처리장치는 그 프로세스로부터 빠져나올 수 없는 스케줄링. 응답 시간들을 쉽게 예측 가능
        - 선점 : 하나의 프로세스에 중앙처리장치가 할당되어 있어도 다른 프로세스가 현재 수행 중인 프로세스를 중지 시키고 자신이 중앙처리장치를 차지할 수 있는 스케줄링. 높은 우선순위를 가진 프로세스들이 빠른 처리를 요구하는 시스템에 유용하며 문맥 교환등으로 인한 오버헤드를
        
    - 우선순위(priority) 스케줄링
        - 각 프로세스에게 우선순위를 부여하여 우순선위가 높은 순서대로 처리하는 스케줄링
        
    - 기한부(deadline) 스케줄링
        - 작업들이 명시된 시간이나 기한 내에 완료되도록 계획하는 스케줄링. 사용자는 사전에 작업이 요구하는 정확한 자원을 제시해야 하나 그런 정보를 예측하기 어려워 적용이 어렵다.
        - RM(Rate Monotonic) 알고리즘 : 각 태스크 주기가 짧을수록 더 높은 우선순위를 부여하는 대표적인 정적 스케줄링 방식이다.
        - EDF(Earliest-Deadline Firts) 알고리즘: 임계 시간이 가장 근접한 태스크에 더 높은 우선순위를 부여하는 대표적인 동적 스케줄링 방식이다.
        
    - 다중 프로세서(Multiple Processor) 스케줄링
        - 각 프로세서가 스스로 스케줄링하며 공동 준비 큐를 조사하여 실행할 프로세서를 선택하는 방식 또는 한 프로세서가 다른 프로세서를 위한 스케줄로서 지정되어 주-종 구조를 구성하는 방식으로 스케줄링.
        
3. 프로세스 스케줄링 알고리즘
    - FCFS(First-Come-First-Served) 스케줄링
        - 프로세스들은 대기큐에 도착한 순서에 따라 중앙처리장치를 할당 받으며, 비선점 스케줄링 방식이다.
    
    - SJF(Shortest Job First) 스케줄링
        - 대기 상태의 프로세스 중에서 수행 시간이 가장 짧은 것을 먼저 수행하는 비선점 스케줄링 방식이다.
        - 수행될 프로세스가 얼마나 긴 것인가를 정확히 알기 어렵다는 문제점이 있다.
        
    - 우선순위(Priority) 스케줄링
        - 우선순위가 각 프로세스에게 주어지며 중앙처리장치는 가장 높은 우선순위를 가진 프로세스로 할당되는 방식이다. 우선순위가 같은 프로세스들은 FCFS 순서로 스케줄링 된다.
        - 우선순위 알고리즘은 무한대기 또는 기아 현상의 문제점이 발생할 수 있다.
            - 에이징(aging) : 무한대기 또는 기아 현상의 해결책으로 오랫동안 시스템에서 대기하는 프로세들의 우선순위를 점진적으로 증가시킨다.
            
    - 라운드 로빈(Round-Robin) 스케줄링
        - FCFS에 의해서 프로세스들이 내보내지며 각 프로세스들은 같은 크기의 CPU 시간을 할당 받는 선점 스케줄링 방식이다.
        - 할당시간의 크기는 보통 10~100ms 정도이며 할당 시간이 너무 크면 FCFS와 동일, 할당 시간이 너무 작으면 문맥 교환을 위한 오버헤드 때문에 성능이 저하될수 있다.
        
    - SRT(Shortest Remaining Time) 스케줄링
        - SJF 스케줄링과 마찬가지로 새로 도착한 프로세스를 포함하여 처리가 완료되는데 가장 짧은 시간이 소요되는 프로세스를 먼저 수행시키는 방식이다.
        - SJF는 비선점, SRT는 실행 중이 프로세스가 선점될 수 있다.
    
    - 다단계 큐(Multilevel Queue) 스케줄링
        - 준비 큐를 다수의 별개 큐로 나누어 프로세스의 특성(기억장치의 요구량, 우선순위, 프로세스의 유형 등)에 근거해 해당 큐에 할당되는 방식이다.
        - 후면작업(background job; 일괄처리) 큐는 선입선출 알고리즘에 의해 스케줄링, 전면작업(foreground job; 대화식) 큐는 라운드 로빈 알고리즘에 의해 스케줄링 된다.
        
    - 다단계 피드백 큐(Multilevel Feedback Queue) 스케줄링
        - 새로운 프로세스는 1단계 큐의 뒤쪽에 들어가며 그 프로세스가 실행 상태가 될때까지 큐를 통하여 **FCFS**에 의해 이동된다. 만약 프로세스가 끝나기 전에 할당 시간이 초과되거나 인터럽트에 의해 중앙처리장치를 양도한다면 그 작업은 다음 하위 단계의 큐로 이동되어 재배치 된다. 마지막 단계의 큐에서는 해당 프로세스가 완료될 때까지 **라운드 로빈(RR)**으로 순환된다.
            
            ![Untitled 3](https://user-images.githubusercontent.com/97429679/168655580-af31fd07-cdf6-466c-bf50-d682e61f8090.png)
            
            <[https://itdexter.tistory.com/394](https://itdexter.tistory.com/394)>
            
        - 시스템의 동적 변환에 잘 적응할 수 있는 적응 기법의 좋은 예이다.
        
    - HRN(High Response ratio Next) 스케줄링
        - SJF의 긴 작업과 짧은 작업 간의 불평등의 약점을 보완한 기법으로 중앙처리장치를 차지하면 그 작업은 완성될 때까지 실행하고 대기시간을 고려하여 우선순위를 결정하는 방식이다.
        - 우선순위 : (대기 시간 + 할당 시간) / 할당 시간 = 시스템 응답 시간
            - 시스템 응답 시간 값이 클수록 우선순위가 높아 진다.
            

## 2. 스레드

### 1. 스레드란?

- 프로세스보다 작고 독립적으로 스케줄링이 가능한 프로그램(CPU에 보내져 실행되는 단위)
- 프로세스의 특성인 자원과 제어에서 제어만 분리한 실행 단위
- 프로세스와 프로세스 간의 잦은 문맥교환으로 성능 저하를 막기 위해 스레드를 사용

### 2. 메모리 입장에서 본 스레드 구조

![Untitled 4](https://user-images.githubusercontent.com/97429679/168655586-9c9372f1-3d3f-4940-8faa-9cf88114aaa2.png)

<[https://www.crocus.co.kr/1403](https://www.crocus.co.kr/1403)>

- 스레드들은 프로세스 내에서 각각의 제어부분인 Stack을 제외한 나머지 공간과 시스템 자원(Code, Data)들을 공유한다.
- 시스템 자원을 공유하므로 프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우 메모리 공간은 물론 시스템 자원 소모도 현격히 줄어 드는 장점이 있다. 또한 프로세스를 생성하여 자원을 할당하는 시간도 줄어들 뿐더러 프로세스를 문맥교환(Context Switching)하는 것보다 오버헤드를 더 줄일 수 있다.

### 3. 스레드와 프로세스의 관계

![Untitled](https://user-images.githubusercontent.com/97429679/168655593-247099d3-06ec-4704-ba8c-84be71946f0e.png)

<[https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jevida&logNo=140189762500](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jevida&logNo=140189762500)>

- 단일 스레드 : 한 프로세스 안에 하나의 스레드를 가지고 있는 스레드
- 다중 스레드 : 하나의 프로세스에 둘 이상의 스레드를 동시에 실행할 수 있는 스레드
- 스레딩 동기화 : 하나의 프로세스에서 2개의 스레드가 같이 공유하고 있는 자원에 동시에 접근하는 것을 막아야 하는데 이를 순차적으로 접근할 수 있도록 제어하는 기법
