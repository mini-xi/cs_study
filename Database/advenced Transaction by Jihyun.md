# Transaction[심화]

# 트랜잭션

- 컴퓨터 과학분야에서 트랜잭션은 “**쪼개질 수 없는 업무처리의 단위**”를 의미
- **거래의 안정성** 확보하기 위한 방법
    - 처리 도중 오류가 발생하면 **모든** 작업을 원상태로 되돌림
    - 처리 과정이 **모두** 성공했을 경우에만 최종적으로 데이터베이스에 반영
- **ACID** 를 특징으로 가짐
- 하나의 트랜잭션은 Commit 되거나 Rollback됨

# 명령어

## Commit

**모든** 부분작업이 정상적으로 완료되면 이 변경사항을 한꺼번에 DB에 반영

## Rollback

부분 작업이 실패하면 트랜잭션 실행 전으로 되돌림

트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 **모든** 연산을 취소하는 연산 

## 아니 꼭 ‘모두’ 롤백해야 하나요 ?

## Savepoint

- 일반적으로 Rollback을 명시하면 INSERT, DELETE, UPDATE 등의 작업 전체가 취소되지만, Savepoint를 사용하면 전체가 아닌 **특정 부분**에서 트랜젝션을 취소
- 취소하려는 지점을  Savepoint로 명시한 뒤 ROLLBACK TO 세이브포인트 이름: 을 실행하면 해당 Savepoint 지점까지 처리한 작업이 rollback
- 지정 방법
    
    `SAVEPOINT name;`
    
- Rollback 형태
    
    `ROLLBACK TO name;`
    

# Transaction의 연산과정

![Untitled](https://user-images.githubusercontent.com/97663140/159160923-1994cf05-06b8-4a18-bb52-03cac74f8933.png)


## 활성(Active)

트랜잭션이 정상적으로 실행 중인 상태

## 실패(Failed)

트랜잭션 실행에 오류가 발생하여 중단된 상태

## 철회(Aborted)

트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

## 부분 완료(Partly Commited)

트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태

## 완료(Committed)

트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

# DBMS의 트랜잭션 관리

## DBMS의 구조, 버퍼 관리자, 버퍼 관리 정책

1. 비휘발성 저장 장치인 디스크에 데이터를 저장 전체 데이터베이스의 일부분을 메인 메모리에 유지
2. DBMS는 데이터를 고정 길이의 **페이지**로 저장, 읽거나 쓸 때 페이지 단위로 입출력
3. 페이지들을 관리하는 모듈을 **페이지 버퍼(page buffer)관리자 또는 버퍼 관리자**라고 부름
4. DBMS는 **질의처리기(Query Proccessor)**와 **저장 시스템(Storage System)**으로 이루어져 있음  

![Untitled 1](https://user-images.githubusercontent.com/97663140/159160920-574e0900-3e2b-4360-8e26-1a03d9a73d2c.png)

1. **버퍼 관리 정책**이 트랜잭션 관리에 매우 중요한 결정을 가져옴
    - 트랜잭션의 UNDO 복구와 REDO 복구가 요구되거나 그렇지 않게 됨
    

## UNDO

1. 아직 완료되지 않은 트랜잭션이 수정한 페이지들도 디스크에 출력될 수 있음
    
    해당 트랙잭션이 어떤 이유로든 정상적으로 종료될 수 없으면 트랜잭션이 변경한 페이지들은 원상복구되어야 함 → UNDO의 정의
    
2. cf)트랜잭션 종료 전에는 어떤 경우에도 수정된 페이지들을 디스크에 쓰지 **않는다면,** UNDO는 메모리 버퍼에 대해서만 이루어지면 되는 식으로 매우 간단해짐 
    
    하지만 이 정책은 매우 큰 크기의 메모리 버퍼가 필요하다는 문제점 
    
3. 수정된 페이지를 디스크에 쓰는 **시점**을 기준
    1. **STEAL** : 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
    2. **-STEAL** :  수정된 페이지들을 최소한 트랜잭션 종료시점(EOT, End of Transaction)까지는 버퍼에 유지하는 정책
4. STEAL 정책은 수정된 페이지가 어떠한 시점에도 디스크에 써질 수 있기 때문에 필연적으로 UNDO 로깅과 복구를 수반, **거의 모든** RDBMS가 채택하는 버퍼 관리 정책

## REDO

1. UNDO 복구의 반대 기념 
2. 이미 커밋한 트랜잭션의 수정을 재반영하는 복구 작업
3. 트랜잭션이 종료되는 시점에 해당 트랜잭션이 수정한 페이지들을 디스크에도 쓸 것인가 여부로 두 가지 정책이 구분
    1. FORCE : 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 **반영하는** 정책
    2. -FORCE : 수정했던 페이지를 트랜잭션 커밋 시점에 디스크에 반영하지 **않는** 정책
    
    주의)-FORCE 정책이 수정했던 페이지(데이터)를 디스크에 반영하지 않을 뿐 커밋 시점에 어떠한 것도 쓰지 않는 것은 아님
    
4. FORCE 정책을 따를 시 → 트랜잭션이 커밋되면 수정되었던 페이지들이 이미 디스크 상의 데이터베이스에 반영 (REDO 복구 필요없음)
5. -FORCE 정책을 따를 시 → 커밋한 트랜잭션의 내용이 디스크 상의 데이터베이스 상에 반영되지 않을 수 있기 때문에 반드시 REDO 복구 필요
6. 사실 FROCE 정책을 따라도 데이터베이스 백업으로터의 복구, 즉 미디어(media) 복구 시에는 REDO 복구가 요구(~~어쩌라는..?~~
7. 거의 모든 DBMS가 채택하는 정책은 **-FORCE** 정책

## 한줄 요약

DBMS는 버퍼 관리 정책으로 **STEAL**과 **-FORCE** 정책을 채택,

이로 인해 **UNDO 복구**와 **REDO 복구**가 모두 필요

## 로그(Log)

1. UNDO 복구와 REDO복구를 위해 널리 쓰이는 구조
2. 로그 레코드의 연속이며 데이터베이스의 모든 갱신 작업을 기록
3. 이론적으로는 안정적인 저장 매체(stable storage)에 기록된다고 하지만, 이는 어떠한 경우에도 손실이 발생하지 않는 이상적인 매체이기 때문에 현실상에는 존재하지 않음. 
4. 대부분의 DBMS는 성능 상의 이유로 하나의 로그를 유지
5. 덧붙이는 방식(append)으로 기록
6. 각 로그 레코드는 고유의 식별자를 가짐 
    1. LNS (Log Sequence Number)
    2. LSA (Log Seqence Adress)
    

## 로그의 분류

1. 로그 데이터는 기록할 오브젝트의 타입에 따라 물리적/논리적 로깅으로 분류
2. 데이터베이스의 상태 또는 변화를 야기한 전이를 기록하느냐에 따라 분류

 ****

![Untitled 2](https://user-images.githubusercontent.com/97663140/159160921-f3bd0f6a-cdb4-4049-8b17-b5d1d13079d1.png)

## 물리적 상태 로깅(Physical State Logging)

1. 가장 널리 쓰이는 기본저거인 로깅 방법
2. UNDO 복구 때에는 이전 이미지로 현재 이미지 대체
3. REDO 복구 때에는 이후 이미지를 반영하는 방식

## 물리적인 전이 로깅(Physical transition logging)

1. 페이지 혹은 레코드에 대해서 이전 및 이후 이미지를 모두 기록하기 보다는
2. XOR 차이점을 기록하는 방식 
    - XOR :**배타적 논리합**
    (排他的論理合, exclusive or)은 수리 논리학에서 주어진 2개의 명제 가운데 1개만 참일 경우를 판단하는 논리 연산이다. 약칭으로 **XOR**, **EOR**, **EXOR** 라고도 쓴다.
        
        ![Untitled 3](https://user-images.githubusercontent.com/97663140/159160922-27f93a91-9665-4d3c-b398-f235d5e42c56.png)
        

## 논리적인 전이 로깅(logical transition logging)

1. operation logging으로도 불림
2. 물리적 로깅이 결과값을 기록하는 방식이라면, 논리적인 로깅은 어떤 일을 했었는가를 기록하는 방식
3. a=a+1 이 있을 때 이전 값0, 이후 값을 기록하는 방식(물리)
4. a=a+1 자체를 기록하는 방식 (논리)
5. REDO를 위해 로그 레코드에 기록된 오퍼레이션을 재수행
6. UNDO를 위해 역 오퍼레이션을 수행 
7. 로그 레코드의 크기를 줄여주며, 물리적으로 복구하기 쉽지 않은 자료 구조에 대한 로깅을 쉽게 해줌 

## 진짜 마지막 최종 주의

로그를 통한 UNDO 복구, REDO 복구는 멱등성(idempotent)를 가져야함.

멱등성은 여러 번 수행하더라도 한 번 수행한 결과와 같아야 한다는 점 의미.

- 물리적인 로그는 멱등성 보장, 논리적인 로그는 복잡함

### 사족

요약 : 스스로 불러온 재앙

사실 저 뒤에도 내용이 많은데 궁금하신 분은 네이버 d2링크를 참조해주세요

**출처**

[[DB]트랜잭션(Transaction)이란?/트랜잭션의 개념,특징, 연산과정/savepoint](https://devuna.tistory.com/30)

[NAVER D2](https://d2.naver.com/helloworld/407507)

[배타적 논리합 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EB%B0%B0%ED%83%80%EC%A0%81_%EB%85%BC%EB%A6%AC%ED%95%A9)